# Linux操作系统

## 系统初始化

### 实模式和保护模式

从x86的开端8086看起，其地址位为20位，因此有效的寻址空间为2^20即1M，数据位为16位(CPU和内存间传输数据靠的都是总线，其中传输数据的叫做数据总线，数据总线中的位数决定了一次能拿多少位数据，而传输内存地址来获取数据的叫做地址总线，地址总线的位数决定了能够寻址的范围大小)

![8086架构图](./pics/8086.jpeg)

上图中可以看到8086内部：
- 数据单元：有8个16位通用存储器`AX, BX, CX, DX, SP, BP, SI, DI`，这些寄存器主要用于CPU计算过程中暂存数据(这些寄存器还可以分成两个8位的寄存器使用，以存储较长或较短的数据)
- 控制单元：都是为16位的寄存器，其中`CS, DS, SS, ES`都称为段寄存器，因为其中存放的都是段地址
  - `IP`表示指令寄存器，指向代码段下一条指令的位置，CPU会根据它不断从内存中取出指令加载到CPU中交给运算单元执行
  - `CS`表示代码段寄存器，指向代码段在内存中的位置
  - `DS`表示数据段寄存器，指向数据段在内存中的位置
  - `SS`表示栈寄存器，其中存储着函数间调用的关系
  - `ES`表示附加段寄存器，当前面几个段寄存器不够用时使用
  - 当加载内存数据到CPU通用寄存器中时，通过`CS, DS`中存放的段起始地址和`IP`中存放的偏移量计算出数据地址(8086中地址位为20位，而起始地址和偏移量都为16位，因此通过`起始地址 << 4 + 偏移量`的方式得到20位地址)

后来随着发展，内存越来越大，总线位数也越来越多，因此就有了32位处理器，其中地址总线有32位，即能寻址4G空间，但此时因为x86是需要保证开放兼容的，因此既要保证32位能够寻址，又要兼容旧版20位也能寻址

通用寄存器中，将8个16位扩展为8个32位即可，因此旧版16位也是能够存储在32位的寄存器中的(为什么不直接把32位分为两个16位寄存器用呢，因为这样就无法直接兼容旧版16位了)

段寄存器中，如果也将16位扩展为32位，但是旧版8086中计算地址需要左移4位来得到20位的地址，也就是说段的起始地址必须是能整除16的地址，而在32位地址中4G内存都可以直接寻址到了，那么到底要不要左移4位呢？因此为了保证兼容，`CS, DS, SS, ES`寄存器仍然是16位，但存储的不再是段的起始地址，段的起始地址被保存在内存中的一张表格中(段描述符表)，而段寄存器中保存的就是该段地址在表格中的哪一项，称为选择子。这样获取段起始地址就需要先从段寄存器中找到段描述符表中的那项，接着从段描述符表中的这项拿到段的起始地址，为了加快速度，往往会将段描述符表加载到CPU缓存中

在32位架构下，将前一种(段寄存器中直接存储段起始地址)称为实模式，后一种(段寄存器中存储段描述符表中的项)称为保护模式，并且保护模式非常灵活，64位架构下也可以兼容。当CPu刚启动的时候是处于实模式的，此时只可以寻址1M，如果需要更多内存时就需要切换到保护模式

为什么叫做保护模式：在实模式下整个物理内存被直接看成分段的区域，系统程序和用户程序没有区别对待，因此如果用户程序指针指向了系统程序物理地址并进行了修改会导致整个系统崩溃，而在保护模式下，通过段描述符表的介入，不但为虚拟存储器提供了硬件支持，还能够快速地进行任务切换和任务保护，再加上完善的特权级别和特权检查制度(在段描述表中每项有4位用于存储特权级别)，能够保证程序和数据的安全

冷知识：
- x86架构开端于Intel 8086，因此叫做x86
- 在Intel 80386开始使用32位架构，因此32位也被称作x86
- AMD对x86架构进行扩充到64位，于是有了x86-64，因此64位也被称作x64/AMD

### BIOS到bootloader

1. BIOS(Basic Input and Output System)称作基本输入输出系统，存储在ROM中(注：ROM是只读存储器与内存条RAM随机存储器不同)
2. CPU处于实模式，内存空间1M，将内存中前64K(0XF0000-0XFFFFF)映射到存储BIOS的ROM中
3. 通电，重置CPU中CS寄存器为0xFFFF，IP寄存器为0x0000，此时第一条指令的地址为0xFFFF0(CS << 4 + IP)，该地址正是BIOS程序。运行BIOS，主要进行系统硬件检查和建立中断向量表和中断服务程序(键盘鼠标通过中断进行输入输出)
4. Grub2(Grand Unified Bootloader Version 2)称作启动加载器，其会将boot.img(由boot.S编译而成，共512字节)安装到启动盘的第一个扇区，这个扇区通常称为MBR(Master Boot Record)主引导扇区，这也就是BIOS启动后能看到的一个可以选择从哪个系统启动的列表(可以通过grub.cfg来配置系统启动所选项)
5. BIOS程序运行完成后，会将boot.img从硬盘加载到内存中0x7c00来运行，由于512字节大小有限，boot.img做不了太多事，主要是加载grub2的另一个镜像core.img到内存中执行
6. core.img是由diskboot.img，lzma_decompress.img，kernel.img等一系列模块组成的
7. boot.img将控制权先交给diskboot.img，其任务就是将core.img的其他部分加载进来，先负责解压缩的lzma_decompress.img，然后是kernel.img(这里的kernel.img不是linux的内核，而是grub2的内核)，最后是各个模块对应的镜像
8. 但是在对kernel.img等镜像解压缩之前所有运行加载的程序都非常小，因此在实模式下1M空间足以，但随着加载的程序越来越大，1M空间就不够用了，此时在真正解压缩前，lzma_decompress.img决定调用real_to_prot以切换到保护模式来加载更多东西
   1. 首先启用分段，在内存中建立段描述符表，将段寄存器中的值改为段选择子，即指向段描述符表中的项
   2. 接着启动分页，将内存分为大小相等的页使用
   3. 打开Gate A20，也就是打开第21根地址线的控制线，此时可寻址大小就不再是2^20的1M了，而是地址总线真正位数所能寻址的空间了
9. 此时已经切换到了保护模式，寻址空间变大，lzma_decompress.img就可以成功解压缩kernel.img了
10. kernel.img中负责解析grub.cfg中的配置信息并显示出让用户选择启动系统的那个列表，当选择了启动某个操作系统后，其会装载指定的内核文件和传递内核启动参数，首先读取内核镜像头部的一些数据结构进行校验，检查通过后会加载整个内核镜像到内存，最后`grub_command_execute ("boot", 0, 0)`才开始真正启动内核

### 内核初始化

内核初始化，运行`init/main.c`中的`start_kernel()`函数，初始化做三件事
- 创建0号进程及各个模块初始化
  - 创建第一个进程0号进程`set_task_stack_end_magic(&init_task)`，这是唯一一个没有通过fork或kernel_thread生成的进程
  - `trap_init()`初始化中断，其中包括很多中断门(Interrupt Gate)用于处理各种中断，比如系统调用就有专门的中断门
  - `mm_init()`初始化内存管理模块
  - `sched_init()`初始化调度模块
  - `vfs_caches_init()`初始化基于内存的文件系统rootfs，VFS(虚拟文件系统)将各种文件系统抽象成统一接口
  - 调用`rest_init()`完成其他初始化工作，包括接下来的1，2号进程创建
- 创建管理/创建用户态进程的1号进程(这是用户态所有进程的祖先)
  - `rest_init()`通过`kernel_thread(kernel_init, ...)`创建1号进程(工作在用户态)
  - x86提供4个Ring分层权限，其中Ring0表示内核态，用于访问核心资源，Ring3表示用户态，用于普通程序
  - 用户态调用系统调用流程：用户态-系统调用-保存寄存器-内核态执行系统调用-恢复寄存器-返回用户态
  - 新进程运行`kernel_init()`函数，其会尝试运行ramdisk(基于内存的文件系统)中的`/init`或者普通文件系统上的`/bin/init, /etc/init`等，不同版本的linux会选择不同的文件启动
    - 首先加载ELF文件
    - 设置保存用户态寄存器的结构体，接着通过`force_iret()`函数从系统调用中返回，这时候会从设置保存的结构体中恢复寄存器中的值，返回后即进入用户态
    - 为什么需要ramdisk：因为文件系统一定是存放在硬件上的，但是硬件种类很多，因此把所有硬件的驱动放入内核是行不通的，于是就搞了个基于内存的文件系统(内存访问是不需要驱动的)，ramdisk上的/init会根据存储系统的类型加载驱动，有了驱动就可以设置真正的文件系统了，接着ramdisk上的/init会启动文件系统上的init
- 创建管理/创建内核态进程的2号进程
  - `rest_init()`通过`kernel_thread(kthreadd, ...)`创建2号进程(工作在内核态)
  - `kthreadd`负责所有内核态线程的调度和管理

### 
