# 消息队列杂录

## 消息队列的作用

- 异步处理
- 流量控制
- 服务解耦

## 消息队列中的差别

RabbitMQ：

好处：支持灵活的路由配置(Exchange)，简单易用
问题：对消息堆积支持不好，性能不是最好的

RocketMQ：

响应时延很小，几乎没什么缺点

Kafka：

生态兼容性最好，但是响应时延比较高

## 消息模型

1. 队列

消息来了加入队列，先进先出，但是存在同一个消息无法被多个用户获取

RabbitMQ是依赖队列实现的，但其通过维护多个队列和Exchange来达到发布-订阅的功能

2. 发布-订阅

虽然RocketMQ是纯正的发布-订阅模式，但是其中还是用到了队列，因为Partition在RocketMQ中是需要被所有消费者组消费的，即被一个组消费过后会给另一个组消费，这就造成了Partition不能一被消费就删除，必须等所有消费组都消费完才行，这时候就引入了队列来保存Partition，然后再设置一个消费位置offset，表示这个位置之前的都被消费过了

## 消息丢失

检测消息丢失：

可以在生产端发出的消息中带上一个连续递增的序号，然后在消费端进行记录

这个方法在RabbitMQ中自然适用，因为其中是队列是能保证顺序的，而像RocketMQ/Kafka中多个队列(Partition)只能保证在队列中的顺序，而各个队列间是不能保证顺序的，因此发消息的时候还要带上队列名

确保消息传递：

- 生产阶段(生产者发送给消息队列)：需要自行捕获消息发送失败的信息，然后重发
- 存储阶段(消息在消息队列中)：写磁盘+集群
- 消费阶段(消费者取消息队列中消息)：需要在处理完所有逻辑后再发送确认消息给消息队列

## 重复消息

当消息队列中没能收到消费端发送的ACK确认，那么消息队列就会产生重复消息给消费端消费，而重复消息往往会对结果造成影响

MQTT中三种传递消息时能够提供的服务质量标准

1. At most once：最多一次，即要么传成功要么就传失败
2. At least once：至少一次，一定保证正确送达一次，但也可能会送达好几次
3. Exactly once：恰好一次，保证只会正确送达一次

解决重复消息带来的问题：幂等性，任意多次操作结果与一次操作的结果相同

At least once + 幂等消费 = Exactly once

1. 为每个消息记录版本号/GUID，写进数据库，在更新/新建判断
2. 为每个消息生成GUID，然后判断该GUID是否在消费过的列表中

## 消息积压

生产端可以从单个消息发送改为多条消息一起发送/多条消息并行发送

消费端通过同步扩容分区数量来增加并发

关于消费端批量消费消息就相当于把消息都先存在本地内存队列中，但这会造成消息队列以为消费端消费数据成功，但是消费端在消费过程中断电就会造成数据丢失，并且批量信息往往是数据库操作，也会造成长事务和锁竞争

## Kafak中的概念

Topic对应的就是个消息队列(RabbitMQ中Topic是模糊路由的意思)

Kafak会将所有消息随机分发到不同的Partition上(虽然说Partition对应的是RabbitMQ中的队列，但是RabbitMQ中每个队列存储的消息都是相同的(如果route相同))，Partition间的消息顺序是不能保证的，但是单个Partition中的消息顺序是能保证的

Kafak中有消费组Consumer Group概念，每个消费组中对应了一个或多个Consumer，在发布-订阅模式下，消费组会消费所有Partition中的消息(即某个消息被一个消费组消费完后会继续传递给下一个消费组消费)，然后消费组中的Consumer会消费所有消息(被一个Consumer消费后就不会被其他Consumer消费了)

Partition中会保留所有消息，直到保留时间到了为止，Partition会为其中的消息分配Partition内唯一的ID，一般称作偏移量(offset)，那么消费组就可以通过这个ID来消费自己没消费过的(也可以消费之前的)

分布式的Kafak中对于一个Partition会存储在不同的机子上，这时候就需要ZooKeeper来选出主副本

