# 并发控制工具

## CountDownLatch

CountDownLatch的作用就是等待其他线程，在创建实例时传入倒数次数，倒数到0后之前等待的线程继续运行

核心await和countDown两个方法，await使线程进入阻塞状态，直到倒数到0为止，countDown就是倒数操作，每次倒数减一

有两个主要使用场景：

1. 一等多：一个线程等待多个线程的信号量都达到(倒数到0)，再继续自己的工作
2. 多等一：多个线程等待某一个线程的信号量(倒数到0)，再同时继续执行

注：CountDownLatch中的倒数不能被重置，即一旦倒数到0，再await就无意义了，要再次倒数就需要新建一个CountDownLatch对象

## CyclicBarrier

CyclicBarrier与CountDownLatch作用基本相同，都是等待其他线程

CyclicBarriera只有await没有countDown，即是通过await的线程数量到达设定值后触发

但有一些不同点：
- CountDownLatch中的倒数量是不可重用的，即倒数到0就失效了，而CyclicBarrier是可重用的，条件满足触发后会恢复到初始化时设置的值(这样说不合理，因为是await累加到设定值即可，而没有倒数操作)
- CountDownLatch针对的是事件，由事件来触发countDown操作，而CyclicBarrier则是针对线程，当线程await数量到达设定值后触发(可以理解为CountDownLatch是倒数到0，而CyclicBarrier则是累加到设定值)

## Semaphore

Semaphore管理着一组permit，permit数量可在初始化时设定，每次操作需要先获取到permit否则就阻塞

核心acquire和release两个方法，acquire获取permit，获取到就继续运行，获取不到就进入阻塞，release释放获取到的permit，应在finally中保证一定会release掉permit

在初始化Semaphore时建议设置为公平的，因为Semaphore控制的往往是耗时操作，如果允许插队，那么后面排队的操作往往需要等待好长的时候(插队的是个耗时操作)才可能继续运行

Semaphore中不要求acquire到的permit必须由该线程自己release掉，可以在别的线程中release，只要逻辑合理即可

使用场景：

争夺有限资源：某些资源有限，不允许同时大量线程同时进行操作，此时可以设定一定量的permit，每个线程需要先获取到permit后再允许继续执行，这样就能保证同时只能规定数量的线程在对某资源进行操作(并且不同线程可以设定不同的需要获取到的permit数量，从而达到为每种线程设定权值的作用)

当Semaphore的permit设置为1时，就等同于一把不可重入锁

注：每个线程acquire到指定数量的permit后必须在最后释放掉获取到的数量的permit，否则就会导致permit越来越少，直到线程永久阻塞

## Condition

Condition依赖于Lock，通过Lock的newCondition方法创建

Condition中的await/signal功能类似与synchronzied中的Object.wait/Object.notify，都是起到阻塞线程然后再被其他线程唤醒

await和signal方法调用前都必须先持有Lock锁，然后await方法会阻塞该线程并释放该锁，signal方法会唤醒一个等待了最长时间的的线程(是公平的)

Condition特殊之处在于一个Lock对象可以创建多个不同的Condition，这样在阻塞和唤醒间的粒度就能细化，例如最常见的循环打印abc问题，就可以为abc分别建立一个Condition，而不用synchronzied中一起notifyAll的操作
