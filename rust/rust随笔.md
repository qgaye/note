# Rust随笔

字符（char）支持所有Unicode，因此char占用4字节

字符串使用UTF-8编码方式，因此在通过切片取中文或emoji时，注意切片索引，因为中文一般占3个字节，emoji占4个字节，如果切片索引未能落在字符之间的边界上，也就是UTF-8字符的边界上，就会造成代码崩溃

String：代表可变的字符串，其在栈中结构为`[指针，容量，长度]`，具体字符串内容保存在堆上
str：代表不可变的字符串（硬编码进可执行文件中的），但因为字符串的长度都是未知的，因此只能通过`&str`的方式进行使用，`&str`也被称为字符串切片，并且所有str都具有`'static`的生命周期

```rust
// &str => String
"str".to_string();
String::from("str");
// String => &str
let s = String::from("str");
&s
&s[..]
s.as_str();
// String + &str
let s = String::from("str");
s.push_str("str");
s + "str"
// 遍历UTF-8字符串
for c in s.chars() {}
```


`[T, n]`是固定长度的数组，其大小是确定的，因此可以分配在栈上，而`[T]`是切片，其大小是不确定的，因此只能分配在堆上，使用也必须通过`&[T]`引用方式使用
`str`也就是`String`的切片，也就是为什么`str`的使用都是`&str`，说的切片，其实就是指切片引用

除了`str`，几乎所有类型都实现了`Sized`特征，
当使用`T`泛型时，rust自动添加了`T: Sized`的特征约束，从而保证接受的类型必须是固定大小的，因此`str`、`[T]`、`Trait`都是不可以直接作为入参或出参的，必须使用引用或`Box`

为什么`Box<str>`不正确，因为除了需要指向String的指针外，还需要长度信息，而`Box<str>`是没有的，而`&[T]`是个胖指针，包含指向堆的指针以及长度


`matches!`宏可以将变量和模式匹配表达式进行匹配，返回bool


使用`as`或`try_into()`进行类型转换


在同作用域下，不可变引用可以共存，但不可变引用和可变引用无法共存，必须在可变引用都使用完后再创建不可变引用，或在不可变引用使用完后再创建可变引用


当入参或出参希望进行特征对象限制，那么就需要通过`Box<dyn Trait>`或`&dyn Trait`限制，而不能直接通过`dyn Trait`，因为实现该Trait的类型大小都是不确定的，而`Box`或`&`在编译期大小是确定的

静态分发：编译器会为每一个泛型参数对应的具体类型生成一份代码，因为是在编译期完成的，对运行期性能完全没有任何影响，`Box<T>`即持有一个直接指向具体类型的指针
动态分发：在运行时才能确定要调用的是哪个方法，`dyn`关键字这是强调动态这一点，`Box<dyn Trait>`会持有一个指向具体类型的指针，以及一个指向vtable的指针（vtable中包括该类型实现的Trait的特征方法）（虚表其实就是用来实现多态）


特征约束：`fn notify(item: &impl Summary)`是`fn notify<T: Summary>(item: &T)`的简写方式
多重约束：`fn notify(item: &(impl Summary + Display))`或`fn notify<T: Summary + Display>(item: &T)`
where约束：
```rust
fn notify<T, U>(t: &T, u: &U) -> i32
     where T: Display + Clone, 
           U: Clone + Debug
```


`self`：表示所有权转移到方法内
`&self`：表示不可变借用
`&mut self`：表示可变借用
`Self`：表示被实现方法的结构体


完全限定语法：`<Type as Trait>::function()`或`Type::function(&self)`主动传入self完成调用


`Result<>?`：如果是Err，则直接return返回，如果OK，则取出其中的值返回
`Option<>?`：如果是None，则直接return返回，如果是Some，则取出其中的值返回
`?`要求必须有变量来承接其返回值，并且该返回值不再是`Result`或`Option`，而是其中值的类型


对于二进制的包，其入口为`src/main.rs`，对于库类型的包，其入口为`src/lib.rs`，项目名称也就是包的名称

绝对路径：从包的根开始，路径名以包名或`crate`作为开头
相对路径：从当前模块开始，以`self`或`super`作为当前模块标识符的开头

默认情况下，包括函数、结构体、变量、模块等都是私有的，父模块无法访问访问子模块中的私有项，但子模块可以访问父模块、父父模块中的私有项
将结构体设置为`pud`后，其内部所有字段还都是私有的，将枚举设置为`pub`后，其内部所有字段都对外可见

需要一层层的进行`pub mod`导出，即导出同级的mod，在2015版本中，使用`folder/mod.rs`方式导出，而在2018中，使用`folder/`和`folder.rs`导出


`{}`：要求实现`Display`
`{:?}`：要求实现`Debug`，大多数类型实现了`Debug`，主要调试阶段使用
`{:#?}`：与`{:?}`基本相同，展示更优雅
`{:.2}`：精度，以精度为2输出小数
`{:#b}`：二进制，`{:#o}`：八进制，`{:#x}`：十六进制
`{:p}`：指针地址
`{{}}`：使用`{`给`{`转义，使用`}`给`}`转义
`{:5}`：填充并左对齐，补齐宽度为5
`{:0$}`：补齐宽度取第0个参数，`{:var$}`：补齐宽度取var变量值
`{var}`：取`println!`参数var，也可以直接捕获上下文中的var变量


闭包实现哪种Fn特征取决于该闭包如何使用被捕获的变量，而不取决于闭包是如何捕获变量的
`FnOnce`：使用变量所有权，所以只能执行一次
`FnMut`：使用变量的可变引用，该闭包被赋给的变量也必须是mut的，因为闭包本质还是个结构体，这个结构体中需要修改变量值，因此该结构体必须是mut的
`Fn`：使用变量的不可变引用
使用`move`将闭包捕获的变量的所有权转移到闭包内，但并不是使用了`move`的就是`FnOnce`，其可能还是`FnMut`或`Fn`
所有闭包都自动实现了`FnOnce`特质，因此都至少可执行一次


`into_iter()`：会夺走所有权
`iter()`：不可变借用
`iter_mut()`：可变借用
`iter().enumerate()`：获取索引和值


newtype：使用元组结构体的方式将已有类型包裹起来，比如`struct Meter(u32)`，其他u32类型无法作为类型为Meter的参数，并且Meter类型也无法使用u32的方法
类型别名：其并不是一个独立的新类型，而是某个类型的别名，比如`type Meter = u32`
`!`：表示函数永不返回任何值，因为永不返回所以该返回值也不会参与到类型检查中

对于元组结构体，可以通过`var.0`的方式获取内部值，其方式和元组是一样的


`Box::leak()`可以将运行时初始化的值变成和程序生命周期相同`'static`，即将目标值强制从内存中泄漏

`Rc`用于共享所有权，核心就是多个地方持有着变量的所有权，而又无法确认谁是持有所有权最久的，因此也就只能通过引用计数的方式来管理
`Cell`和`RefCell`用于实现内不可变性，用`Cell`或`RefCell`包裹后的字段即使结构体非mut也可以修改字段值


`impl !Trait for Type`其中的`!`意思为Type移除该特征Trait


`const`会内联，而`static`则不会内联，都必须是在编译期可以计算出的值

运行期初始化：`lazy_static!{ static ref VAR: }`

