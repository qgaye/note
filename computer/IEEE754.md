# IEEE754

整数(十进制 -> 二进制)：将十进制整数除2得到商和余数，接着再用商除2不断得到商和余数直到商小于1，最后将所有的余数逆序排列(先得到余数作为低位)得到二进制数

`60 -> 60 / 2 = (30, 0) -> 30 / 2 = (15, 0) -> 15 / 2 = (7, 1) -> 7 / 2 = (3, 1) -> 3 / 2 = (1, 1) -> 1`，因此十进制的60转化为二进制111100

原理：假设十进制整数A转化为的二进制数为edcba的形式，按位权展开为`A = e * 2^4 + d * 2^3 + c * 2^2 + b * 2^1 + a * 2^0`，将A除2即`A / 2 = (e * 2^4) / 2 + (d * 2^3) / 2 + (c * 2^2) / 2 + (b * 2^1) / 2 + (a * 2^0) / 2`，可以发现edcb系数因为都是2的1次方以上，因此除2是一定能除尽的，但a系数是2^0为1那么是一定没法被2除尽的(因为是二进制，a要么是1要么是0)，于是`A / 2`中`e * 2^3 + d * 2^2 + c * 2^1 + b * 2^0`为商，`a * 2^0`即`a`为余数，接着继续将上一步的商`A / 2`再除2，于是就得到了`b`，以此类推最后就得到了二进制数edcba

位权：即代表某进制下该位置的数字需要乘以的常数，比如十进制下依次为10^0，10^1，10^2...，二进制下依次为2^0，2^1，2^2...

小数(十进制 -> 二进制)：将十进制小数乘2得到的积，将积的整数部分(1/0)取出余下的小数部分继续乘2再得到一个积直到积中的小数部分为0，最后将所有的整数部分顺序排列(先得到的整数部分作为高位)得到二进制数

`0.375 -> 0.375 * 2 = 0.75 -> 0.75 * 2 = 1.5 -> 0.5 * 2 = 1.0`，因此十进制的0.375转化为二进制0.011

原理：同样假设十进制小数A转化为0.abc的形式，按位权展开为`A = a * 2^-1 + b * 2^-2 + c * 2^-3`，将A乘2即`A * 2 = (a * 2^-1) * 2 + (b * 2^-2) * 2 + (c * 2^-3) * 2`，可以发现`(a * 2^-1) * 2`即`a`也就是成为了整数部分，其余的系数因为都是2的-2次以下，因此乘2后依旧还是小数(系数为0/1)，接着将除去整数部分的积继续乘2即能得到整数部分b，以此类推最后就得到了二进制数0.abc

但是小数本身存在个问题，任何进制下都只能够精确表示由该进制位权和组成的小数，比如十进制的小数只能精确表示10^n的和的小数，0.123实际上表示的是`1 * 10^-1 + 2 * 10^-2 + 3 * 10^-3`，而1 / 3的值0.3333无限循环在十进制下是无法精确表示的，同理二进制的小数就只能精确表示2^n的和的小数

在十进制小数转二进制小数时，因为十进制下位权的粒度相较于二进制更细(10^-1对比2^-1)，因此就存在十进制下能通过有限位精确表示的小数却无法在二进制下通过有限位小数精确表示(在二进制下成为了无限循环小数)，至于那些在十进制下就无法精确表示的小数就更不可能在二进制下被精确表示了，既然无法通过有限位精确表示，那么就只能用个近似值来代替

到此为止其实是解释了为什么在十进制下是能够精确表示的小数却无法在二进制下精确表示而只能存储近似值，这其实和IEEE754并无直接关系，IEEE754只是一个二进制浮点数的运算标准，从而来规范浮点数的表示和运算来提升程序的可靠性和可移植性

说到浮点数，先来看看其对应的定点数，定点数是指小数点位置固定，表现在存储上即前多少位固定为整数部分后多少位固定为小数部分，这样可表示的数字范围就很小，因此就有了浮点数，即小数点的位置浮动来表示更大范围的数字，在十进制中123.45表示为浮点数即1.2345 * 10^2

在IEEE754中，任意一个浮点数可以表示为`(-1) ^ 符号位 * 2 ^ (指数位) * 有效数字`，有效数字 = 1 + 小数位
- 单精度(32位)：`1位符号位 + 8位指数位 + 23位小数位`
- 双精度(64位)：`1位符号位 + 11位指数位 + 52位小数位`

符号位：0表示正数，1表示负数
有效数字：有效数字的范围为大于等于1小于2，在存储时首位的1(整数部分的1)会被舍弃只保存小数部分，以多保存一位小数，因此在计算时需要将小数位 + 1
指数位：指数是允许正数和负数，因此指数位的真实值是需要减去一个中间数，对于32位而言中间数为127，对于64为则是1023，此外指数位还分为三种情况
    - 不全为0或不全为1：指数位 - 127/1023得到真实值，然后小数位 + 1得到有效数字
    - 全为0：指数位为0时，当小数位也为0则表示值为0，如果小数位不为0则表示无限接近于0的值
    - 全为1：小数位如果全为0表示正负无穷大，正负由符号位决定，如果小数位不全等于0则不表示任何数

举例：十进制的5.25，转化成二进制为101.01，相当于1.0101 * 2^2，那么转化为IEEE754的格式，符号位为0，指数位为2，有效数字为0101 

总结：在IEEE754标准下，使用单精度和双精度浮点数时需要牢记它们分别只有7位和15位有效数字(32位小数位为23位，加上省掉的一位，因此`log10(2^24) = 7`)

## 0.1 + 0.2 != 0.3

`0.1 + 0.2`表达式的计算结果在绝大部分的编程语言的输出都是0.300000004(如果是64位double类型则是0.30000000000000004)，这正是因为0.1和0.2都无法在二进制下通过有限位小数精确表示(转化为二进制都成了无限循环小数)因为只能存储近似值，于是在计算时固然会计算出近似0.3的值，而大部分编程语言都是采用的IEEE754标准来存储浮点数，因此计算结果也都是0.300000004

那么怎么才能计算出正确的0.3呢，主要有两种方法
- 分数：使用分数的方式来表示小数，在计算时即是分数的计算，最后返回转化为浮点数，即`0.1 + 0.2`转化为`1 / 10 + 2 / 10`
- `Decimal`：分别存储去除小数点后的全部数字，小数的位数，全部的有效位数，相当于将小数转化为整数后存储，即`0.1 + 0.2`转化为`1 * 10^-1 + 2 * 10^-1`(但是这方法只能解决小数无法通过二进制形式准确表达的情况，对于无限循环小数还是无能为力，无限循环小数还是得需要分数的方式)

## 浮点数加法的精度丢失

浮点数在做加法时，首先两个浮点数的指数位需要对齐，即把指数位都统一成两个中较大的一个，因此较小的指数位的数字就需要将有效数字位进行右移来增大其指数位，指数位对齐后将有效数字位进行相加即可，整个过程只需要移位 + 加法器即可，无需引入新的特殊电路

但是在指数位统一时需要将一个浮点数的有效数字进行右移，假设这个浮点数的第23位有效数字是1(32位的浮点数)，那么只要右移一位那么这个有效数字1就会被抹去，从而造成指数位较小的那个浮点数在加法计算发生前就发生精度丢失，除非被右移的有效数字都是0。并且当两个浮点数的指数位相差越大就会造成丢失的精度也越大，32位的浮点数小数位为23位，如果两个浮点数的指数位相差23位，指数位较小的浮点数将小数位右移24位后，其实就是将所有有效数字全部丢失了(23位+默认首位1)，那么加上这个较小的浮点数就等于没加。所以在实际计算时只要两个浮点数相差2^24，那么两个浮点数相加后结果就完全等于较大的那个浮点数

一次加法造成的精度丢失或许是可以被容忍的，但是将加上一个相差2^24的浮点数的加法操作进行上万次，那么结果和加一次一样都等于没加，此时就会造成巨大的精度丢失。Kahan Summation算法能够避免大数吃小数的情况，在计算时`sum = a + b`是不准确的，于是同时计算`temp = (a + b) - a - b`，temp值即因为右移造成的精度丢失的误差值，于是将这个temp值保存下来在下一次加法时将temp值再加上，即补上了上一步加法中的误差值，从而避免了这类的精度丢失问题
