# IEEE754

整数(十进制 -> 二进制)：将十进制整数除2得到商和余数，接着再用商除2不断得到商和余数直到商小于1，最后将所有的余数逆序排列(先得到余数作为低位)得到二进制数

`60 -> 60 / 2 = (30, 0) -> 30 / 2 = (15, 0) -> 15 / 2 = (7, 1) -> 7 / 2 = (3, 1) -> 3 / 2 = (1, 1) -> 1`，因此十进制的60转化为二进制111100

原理：假设十进制整数A转化为的二进制数为edcba的形式，按位权展开为`A = e * 2^4 + d * 2^3 + c * 2^2 + b * 2^1 + a * 2^0`，将A除2即`A / 2 = (e * 2^4) / 2 + (d * 2^3) / 2 + (c * 2^2) / 2 + (b * 2^1) / 2 + (a * 2^0) / 2`，可以发现edcb系数因为都是2的1次方以上，因此除2是一定能除尽的，但a系数是2^0为1那么是一定没法被2除尽的(因为是二进制，a要么是1要么是0)，于是`A / 2`中`e * 2^3 + d * 2^2 + c * 2^1 + b * 2^0`为商，`a * 2^0`即`a`为余数，接着继续将上一步的商`A / 2`再除2，于是就得到了`b`，以此类推最后就得到了二进制数edcba

位权：即代表某进制下该位置的数字需要乘以的常数，比如十进制下依次为10^0，10^1，10^2...，二进制下依次为2^0，2^1，2^2...

小数(十进制 -> 二进制)：将十进制小数乘2得到的积，将积的整数部分(1/0)取出余下的小数部分继续乘2再得到一个积直到积中的小数部分为0，最后将所有的整数部分顺序排列(先得到的整数部分作为高位)得到二进制数

`0.375 -> 0.375 * 2 = 0.75 -> 0.75 * 2 = 1.5 -> 0.5 * 2 = 1.0`，因此十进制的0.375转化为二进制0.011

原理：同样假设十进制小数A转化为0.abc的形式，按位权展开为`A = a * 2^-1 + b * 2^-2 + c * 2^-3`，将A乘2即`A * 2 = (a * 2^-1) * 2 + (b * 2^-2) * 2 + (c * 2^-3) * 2`，可以发现`(a * 2^-1) * 2`即`a`也就是成为了整数部分，其余的系数因为都是2的-2次以下，因此乘2后依旧还是小数(系数为0/1)，接着将除去整数部分的积继续乘2即能得到整数部分b，以此类推最后就得到了二进制数0.abc

但是小数本身存在个问题，任何进制下都只能够精确表示由该进制位权和组成的小数，比如十进制的小数只能精确表示10^n的和的小数，0.123实际上表示的是`1 * 10^-1 + 2 * 10^-2 + 3 * 10^-3`，而1 / 3的值0.3333无限循环在十进制下是无法精确表示的，同理二进制的小数就只能精确表示2^n的和的小数

在十进制小数转二进制小数时，因为十进制下位权的粒度相较于二进制更细(10^-1对比2^-1)，因此就存在十进制下能通过有限位精确表示的小数却无法在二进制下通过有限位小数精确表示(在二进制下成为了无限循环小数)，至于那些在十进制下就无法精确表示的小数就更不可能在二进制下被精确表示了，既然无法通过有限位精确表示，那么就只能用个近似值来代替

到此为止其实是解释了为什么在十进制下是能够精确表示的小数却无法在二进制下精确表示而只能存储近似值，这其实和IEEE754并无直接关系，IEEE754只是一个二进制浮点数的运算标准，从而来规范浮点数的表示和运算来提升程序的可靠性和可移植性

说到浮点数，先来看看其对应的定点数，定点数是指小数点位置固定，表现在存储上即前多少位固定为整数部分后多少位固定为小数部分，这样可表示的数字范围就很小，因此就有了浮点数，即小数点的位置浮动来表示更大范围的数字，在十进制中123.45表示为浮点数即1.2345 * 10^2

在IEEE754中，任意一个浮点数可以表示为`(-1) ^ 符号位 * 2 ^ (指数位) * 有效数字`，有效数字 = 1 + 小数位
- 单精度(32位)：`1位符号位 + 8位指数位 + 23位小数位`
- 双精度(64位)：`1位符号位 + 11位指数位 + 52位小数位`

符号位：0表示正数，1表示负数
有效数字：有效数字的范围为大于等于1小于2，在存储时首位的1(整数部分的1)会被舍弃只保存小数部分，以多保存一位小数，因此在计算时需要将小数位 + 1
指数位：指数是允许非负的，因此指数位的真实值是需要减去一个中间数，对于32位而言中间数为127，对于64为则是1023，此外指数位还分为三种情况
    - 不全为0或不全为1：指数位 - 127/1023得到真实值，然后小数位 + 1得到有效数字
    - 全为0：指数位等于 1 - 127/1023，小数位不再 + 1，这个情况表示0或无限接近0的小数
    - 全为1：小数位如果全为0表示正负无穷大，如果小数位不全等于0则不表示任何数

举例：十进制的5.25，转化成二进制为101.01，相当于1.0101 * 2^2，那么转化为IEEE754的格式，符号位为0，指数位为2，有效数字为0101 

总结：在IEEE754标准下，使用单精度和双精度浮点数时需要牢记它们分别只有7位和15位有效数字(32位小数位为23位，加上省掉的一位，因此`log10(2^24) = 7`)

## 0.1 + 0.2 != 0.3

`0.1 + 0.2`表达式的计算结果在绝大部分的编程语言的输出都是0.300000004(如果是64位double类型则是0.30000000000000004)，这正是因为0.1和0.2都无法在二进制下通过有限位小数精确表示(转化为二进制都成了无限循环小数)因为只能存储近似值，于是在计算时固然会计算出近似0.3的值，而大部分编程语言都是采用的IEEE754标准来存储浮点数，因此计算结果也都是0.300000004

那么怎么才能计算出正确的0.3呢，主要有两种方法
- 分数：使用分数的方式来表示小数，在计算时即是分数的计算，最后返回转化为浮点数，即`0.1 + 0.2`转化为`1 / 10 + 2 / 10`
- `Decimal`：分别存储去除小数点后的全部数字，小数的位数，全部的有效位数，相当于将小数转化为整数后存储，即`0.1 + 0.2`转化为`1 * 10^-1 + 2 * 10^-1`(但是这方法只能解决小数无法通过二进制形式准确表达的情况，对于无限循环小数还是无能为力，无限循环小数还是得需要分数的方式)
