# 字符集和字符编码

## ASCII

ASCII规定了128个字符，包括数字，字母，符号等，从0-127，因此7位二进制即可表示，ASCII占用一字节且最高位统一为0

## GB2312/GBK

英文用128个字符来编码是足够的，但其他语言则是远远不够的，于是其他国家首先将ASCII中一字节的最高位利用起来，而中文这些语言发现还是不够，于是就用两个字节来表示一个字符

GB2312规定：一个字节小于127时表示的字符与ASCII相同，但当两个字节都大于127时就表示一个汉字，这样就组合出了7000+汉字了。并且在该编码中还将数学符号，罗马字母和ASCII中本来一字节的字符(字母，数字，符号)用两字节重新编码一次，这也就是常说的全角字符，而小于127的就叫做半角字符

可以说GB2312是对ASCII的一种扩展，因为GB2312是对中文的扩展，而别的国家也会有针对自己语言字符的扩展(比如日文的Shift_JIS，韩文的Euc-kr)，也就是说任何大于128(大于ASCII编码)的字符在不同的扩展中代表着不同的字符，无法通用转化，这也就是为什么需要Unicode字符集的存在

因为汉字太多了，在GB2312中一些生僻汉字并没能编码进去，于是GBK中直接规定只要第一个字符大于127就表示这是个汉字的开始，GBK包括了GB2312中所有内容还新增了20000+汉字

## ANSI

ANSI有些特别，它其实既不是字符集也不是字符编码，其本身是美国国家标准会(American National Standards Institute)的简称，其主要指的是一系列字符编码，这些字符编码兼容ASCII，即0-127表示的字符和ASCII表示的字符相同，但大于127都各自表示各自的字符，互相间无法兼容的字符编码

在Unicode这种统一字符集诞生前，因为ASCII只能表示英文，数字及符号，那么其他国家自身的字符无法被表示，于是其他国家都各自利用起了大于127的位置来表示各自国家的字符，从而实现了各自的兼容ASCII又能表示各自特有字符的字符编码，比如中文的GB2312，日文的Shift_JIS，欧洲的Latin1(ISO-8859-1)等，这些字符集被ANSI组织收入并编号，于是Windows在那个混乱的时代为不同国家的系统设置各自不同的字符编码，在Windows中就将他们统称为ANSI

## Unicode

Unicode是个字符集，其将全世界所有的字符包含在一个集合中，计算机只要支持该字符集便能够显示所有字符而不会乱码

Unicode从0开始为每个字符指定一个编号(称作码点，code point)，Unicode表示中紧跟在U+后的十六进制数即Unicode的码点

因为世界上的字符也是不断在增加的，比如emoji的加入等，因此Unicode也不是一次性定义的，而是分区定义的。每个分区可以存放65536(2^16)个字符，称为一个平面(plane)，目前一共17个平面

最前面的65536个字符称为基本平面(BMP，Basic Multilingual Plane)，码点范围为U+0000到U+FFFF，所有最常见的字符都在这个平面内。剩下的字符都在辅助平面内(SMP)

Unicode只是规定了字符和一个唯一码点对应的关系，但并没有规定该字符的码点在计算机中应该如何存储(其只是个字符集，而不负责字符编码)。Unicode如何由U+的形式被编码成二进制是由UTF(Unicode Transformation Formats)规定的。类似UTF-8/UTF-16是编码规则，其规定了字符集Unicode中字符如何转化为二进制形式，再如何从二进制形式转化为字符集Unicode中字符

## UTF-8

UTF-8是Unicode的最广泛的一种编码方式，其实现了对ASCII的向后兼容，最大特点就是变长，可以根据字符选择使用1-4字节表示

UTF-8编码规则：
- 对于单字节表示的字符，第一位为0，后面7位对应Unicode码点，因此0-127号字符与ASCII完全相同，也意味着ASCII编码的文档可以用UTF-8编码打开而没有任何问题
- 对于N(N > 1)个字节表示的字符，第一个字节的前N位设为1，第N+1位设为0，剩余N-1个字节的前两位都设为10，剩下的二进制位则用该字符的Unicode码点来填充

因此UTF-8编码下，如果第一个字节的第一位为0就说明该字符占用一个字节，如果第一个字节的第一位为1，则看有多少个连续的1就代表该字符占用多少字节

## UTF-16

UTF-16结合了定长和变长两种编码方式的特点，对于在基本平面(BMP)的字符占2字节，辅助平面的字符占4字节，因此UTF-16编码中字符要么占2字节要么占4字节

UTF-16编码规则：
- 基本平面内字符(`U+000 ~ U+FFFF`)，Unicode直接转化为2字节的二进制存储
- 辅助平面内字符(`U+10000 ~ U+10FFFF`)，将Unicode值减去`0x10000`得到20位，将20位中前10位加上`0XD800`作为高十位存在前2字节中(范围`U+D800 ~ U+DBFF`)，将20位中后10位加上`0xDC00`作为低十位存在后2字节中(范围`U+DC00 ~ U+DFFF`)

为什么辅助平面内字符要经过一系列转化后才存到4字节中内？就是为了解码时能够分辨该字符是2字节的还是4字节的，因为在基本平面内`U+D800 ~ U+DFFF`是一个空段，即这些码点不对应任何字符，于是UTF-16编码到4字节时就需要将前2字节和后2字节都映射到这个空段中，从而在解码时发现2字节在空段中就说明该字符占4字节

## UTF-32

UTF-32是最直观的编码方式，每个码点都使用4字节表示，字节内二进制与码点一一对应

UTF-32优点在于解码编码转化简单高效，缺点就是浪费空间，比如ASCII中占一字节的字符到UTF-32中就需要占用4字节，也正是因为这个缺点导致实际中该编码方式并不多被使用

## 字符串中的编码

在Java和JavaScript中String类型的内部编码都是UTF-16，就Java而言早期其实不是UTF-16而是UCS-2，UCS-2的目的和Unicode是一样的，都是为了提供个统一的字符集，但同时UCS-2也是个定长编码，固定2字节(因为早期字符少，2字节足以表示)，后来USC-2和Unicode合并了，UTF-16编码明确宣布是UCS-2的超集，即基本平面继续采用2字节表示，于是Java中String的编码也转换到了UTF-16(早期因为Unicode包含的字符较少，因此Java认为2字节就能表示所有的字符了，于是char类型也被设计为了2字节，但到现在辅助平面内的字符比如emoji就无法通过char表示)

注：Java9之前String内部由`char[]`实现，因为char固定占2字节符合UTF-16中2/4字节变长的编码，由于String是堆内存占用大头，而UTF-16中对ASCII由1字节编码成2字节从而造成内存空间浪费，于是在Java9开始内部改为`byte[] + coder`实现，coder代表Latin1或UTF-16编码方式，如果String中是西文即可以使用Latin1编码，Latin1是固定单字节编码，因此可以很大程度节约内存空间，而如果String中有汉字等其他字符就采用UTF-16编码(coder = 0代表Latin1，coder = 1代表UTF-16)

较现代的编程语言都开始使用UTF-8作为String内部的编码格式，比如go/rust等，UTF-8是1到4字节变长编码的，可以节约内存空间，但是UTF-8的编码方式使得String中`length()`方法获取到的是该字符串所占的字节数而不是字符数量，`charAt(i)`方法获取到的是byte数组i下标的值而不是第i个字符，比如go中就需要将字符串转化为`rune[]`后才能获取字符数量和获取指定字符，而rune正是固定4字节，也可以理解为转化为UTF-32编码，于是固定4字节就表示一个字符

这里要着重说一下Java中String的`length()`和`charAt()`方法，`length()`方法准确说是获取到代码单元数量(代码单元(code unit)：编码规则中最短的位组合单元，比如UTF-8中就是1字节，而UTF-16中就是2字节)而不是字符数量，只是因为基本平面在UTF-16中都占2字节于是只要字符在基本平面内`length()`方法就能正确获取到字符数量，如果在辅助平面内的字符，UTF-16中用4字节存储也就是2个代码单元，此时`length()`方法就无法返回正确的字符数量了，`charAt()`方法也同理，在基本平面的字符都能够通过该方法获取到该字符，而在辅助平面内的就无法获取到(此时2字节表示的是个无效值)

```java
String s1 = "hello";
s1.length();    // 5
String s2 = "你好";
s2.length();    // 2
String s3 = "hello👴";
s3.length();    // 7，因为emoji需要4字节存储，故占2个代码单元
```

那么如何在字符串中包含辅助平面字符的情况下获取到正确的字符`length()`和`charAt()`的值呢？，在Java1.5后就提供了基于码点(code point)的方法，这些方法参数中的index使用的是代码单元(code point)

```java
public int codePointAt(int index)
public int codePointCount(int beginIndex, int endIndex)
```
