# 字符集和字符编码

## ASCII

ASCII规定了128个字符，包括数字，字母，符号等，从0-127，因此7位二进制即可表示，ASCII占用一字节且最高位统一为0

## GB2312/GBK

英文用128个字符来编码是足够的，但其他语言则是远远不够的，于是其他国家首先将ASCII中一字节的最高位利用起来，而中文这些语言发现还是不够，于是就用两个字节来表示一个字符

GB2312规定：一个字节小于127时表示的字符与ASCII相同，但当两个字节都大于127时就表示一个汉字，这样就组合出了7000+汉字了。并且在该编码中还将数学符号，罗马字母和ASCII中本来一字节的字符(字母，数字，符号)用两字节重新编码一次，这也就是常说的全角字符，而小于127的就叫做半角字符

可以说GB2312是对ASCII的一种扩展，因为GB2312是对中文的扩展，而别的国家也会有针对自己语言字符的扩展(比如日文的Shift_JIS，韩文的Euc-kr)，也就是说任何大于128(大于ASCII编码)的字符在不同的扩展中代表着不同的字符，无法通用转化，这也就是为什么需要Unicode字符集的存在

因为汉字太多了，在GB2312中一些生僻汉字并没能编码进去，于是GBK中直接规定只要第一个字符大于127就表示这是个汉字的开始，GBK包括了GB2312中所有内容还新增了20000+汉字

## ANSI

ANSI有些特别，它其实既不是字符集也不是字符编码，其本身是美国国家标准会(American National Standards Institute)的简称，其主要指的是一系列字符编码，这些字符编码兼容ASCII，即0-127表示的字符和ASCII表示的字符相同，但大于127都各自表示各自的字符，互相间无法兼容的字符编码

在Unicode这种统一字符集诞生前，因为ASCII只能表示英文，数字及符号，那么其他国家自身的字符无法被表示，于是其他国家都各自利用起了大于127的位置来表示各自国家的字符，从而实现了各自的兼容ASCII又能表示各自特有字符的字符编码，比如中文的GB2312，日文的Shift_JIS，欧洲的Latin1(ISO-8859-1)等，这些字符集被ANSI组织收入并编号，于是Windows在那个混乱的时代为不同国家的系统设置各自不同的字符编码，在Windows中就将他们统称为ANSI

## Unicode

Unicode是个字符集，其将全世界所有的字符包含在一个集合中，计算机只要支持该字符集便能够显示所有字符而不会乱码

Unicode从0开始为每个字符指定一个编号(称作码点，code point)，Unicode表示中紧跟在U+后的十六进制数即Unicode的码点

因为世界上的字符也是不断在增加的，比如emoji的加入等，因此Unicode也不是一次性定义的，而是分区定义的。每个分区可以存放65536(2^16)个字符，称为一个平面(plane)，目前一共17个平面

最前面的65536个字符称为基本平面(BMP，Basic Multilingual Plane)，码点范围为U+0000到U+FFFF，所有最常见的字符都在这个平面内。剩下的字符都在辅助平面内(SMP)

Unicode只是规定了字符和一个唯一码点对应的关系，但并没有规定该字符的码点在计算机中应该如何存储(其只是个字符集，而不负责字符编码)。Unicode如何由U+的形式被编码成二进制是由UTF(Unicode Transformation Formats)规定的。类似UTF-8/UTF-16是编码规则，其规定了字符集Unicode中字符如何转化为二进制形式，再如何从二进制形式转化为字符集Unicode中字符

## UTF-8

UTF-8是Unicode的最广泛的一种编码方式，其实现了对ASCII的向后兼容，最大特点就是变长，可以根据字符选择使用1-4字节表示

UTF-8编码规则：
- 对于单字节表示的字符，第一位为0，后面7位对应Unicode码点，因此0-127号字符与ASCII完全相同，也意味着ASCII编码的文档可以用UTF-8编码打开而没有任何问题
- 对于N(N > 1)个字节表示的字符，第一个字节的前N位设为1，第N+1位设为0，剩余N-1个字节的前两位都设为10，剩下的二进制位则用该字符的Unicode码点来填充

因此UTF-8编码下，如果第一个字节的第一位为0就说明该字符占用一个字节，如果第一个字节的第一位为1，则看有多少个连续的1就代表该字符占用多少字节

## UTF-16

UTF-16结合了定长和变长两种编码方式的特点，对于在基本平面(BMP)的字符占2字节，辅助平面的字符占4字节，因此UTF-16编码中字符要么占2字节要么占4字节

UTF-16编码规则：
- 基本平面内字符(`U+000 ~ U+FFFF`)，Unicode直接转化为2字节的二进制存储
- 辅助平面内字符(`U+10000 ~ U+10FFFF`)，将Unicode值减去`0x10000`得到20位，将20位中前10位加上`0XD800`作为高十位存在前2字节中(范围`U+D800 ~ U+DBFF`)，将20位中后10位加上`0xDC00`作为低十位存在后2字节中(范围`U+DC00 ~ U+DFFF`)

为什么辅助平面内字符要经过一系列转化后才存到4字节中内？就是为了解码时能够分辨该字符是2字节的还是4字节的，因为在基本平面内`U+D800 ~ U+DFFF`是一个空段，即这些码点不对应任何字符，于是UTF-16编码到4字节时就需要将前2字节和后2字节都映射到这个空段中，从而在解码时发现2字节在空段中就说明该字符占4字节

## UTF-32

UTF-32是最直观的编码方式，每个码点都使用4字节表示，字节内二进制与码点一一对应

UTF-32优点在于解码编码转化简单高效，缺点就是浪费空间，比如ASCII中占一字节的字符到UTF-32中就需要占用4字节，也正是因为这个缺点导致实际中该编码方式并不多被使用

## `锟斤拷`的问题

当GBK编码的文件转化为UTF-8编码时，因为GBK字符集中会有一些字符在Unicode编码中不存在(比如`亻因`这个汉字并没有被编码进Unicode字符集)，于是就会使用`U+FFFD`来表示这些不存在于Unicode中的字符(占位符：该字符用于替换一个无法从其他编码转换解析的字符，Unicode中使用`U+FFFD`来表示占位符)，而`U+FFFD`用UTF-8编码就是`EF BF BD`，两个连续的`U+FFFD`以GBK编码就是`EFBF BDEF BFBD`，对应GBK字符集中就是`锟斤拷`这三个字，这也就是为什么会经常看到`锟斤拷`这样的乱码格式

这种乱码现象不仅仅会出现在GBK和UTF-8之间的转换中，只要从一个字符集转化到另一个字符集且两个字符集包含的字符集不相同且转换的文件中存在另一个字符集中没有的字符时，就会发生乱码

## 字符串中的编码

在Java和JavaScript中String类型的内部编码都是UTF-16，就Java而言早期其实不是UTF-16而是UCS-2，UCS-2的目的和Unicode是一样的，都是为了提供个统一的字符集，但同时UCS-2也是个定长编码，固定2字节(因为早期字符少，2字节足以表示)，后来USC-2和Unicode合并了，UTF-16编码明确宣布是UCS-2的超集，即基本平面继续采用2字节表示，于是Java中String的编码也转换到了UTF-16(早期因为Unicode包含的字符较少，因此Java认为2字节就能表示所有的字符了，于是char类型也被设计为了2字节，但到现在辅助平面内的字符比如emoji就无法通过char表示)

注：Java9之前String内部由`char[]`实现，因为char固定占2字节符合UTF-16中2/4字节变长的编码，由于String是堆内存占用大头，而UTF-16中对ASCII由1字节编码成2字节从而造成内存空间浪费，于是在Java9开始内部改为`byte[] + coder`实现，coder代表Latin1或UTF-16编码方式，如果String中是西文即可以使用Latin1编码，Latin1是固定单字节编码，因此可以很大程度节约内存空间，而如果String中有汉字等其他字符就采用UTF-16编码(coder = 0代表Latin1，coder = 1代表UTF-16)

较现代的编程语言都开始使用UTF-8作为String内部的编码格式，比如go/rust等，UTF-8是1到4字节变长编码的，可以节约内存空间，但是UTF-8的编码方式使得String中`length()`方法获取到的是该字符串所占的字节数而不是字符数量，`charAt(i)`方法获取到的是byte数组i下标的值而不是第i个字符，比如go中就需要将字符串转化为`rune[]`后才能获取字符数量和获取指定字符，而rune正是固定4字节，也可以理解为转化为UTF-32编码，于是固定4字节就表示一个字符

这里要着重说一下Java中String的`length()`和`charAt()`方法，`length()`方法准确说是获取到代码单元数量(代码单元(code unit)：编码规则中最短的位组合单元，比如UTF-8中就是1字节，而UTF-16中就是2字节)而不是字符数量，只是因为基本平面在UTF-16中都占2字节于是只要字符在基本平面内`length()`方法就能正确获取到字符数量，如果在辅助平面内的字符，UTF-16中用4字节存储也就是2个代码单元，此时`length()`方法就无法返回正确的字符数量了，`charAt()`方法也同理，在基本平面的字符都能够通过该方法获取到该字符，而在辅助平面内的就无法获取到(此时2字节表示的是个无效值)

```java
String s1 = "hello";
s1.length();    // 5
String s2 = "你好";
s2.length();    // 2
String s3 = "hello👴";
s3.length();    // 7，因为emoji需要4字节存储，故占2个代码单元
```

那么如何在字符串中包含辅助平面字符的情况下获取到正确的字符`length()`和`charAt()`的值呢？·在Java1.5后就提供了基于码点(code point)的方法，这些方法参数中的index使用的是代码单元(code point)

```java
public int codePointAt(int index)
public int codePointCount(int beginIndex, int endIndex)
```

## 参考

- [彻底弄懂Unicode编码](https://liyucang-git.github.io/2019/06/17/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Unicode%E7%BC%96%E7%A0%81/)
- [一个Java字符串中到底有多少个字符?](https://colobu.com/2019/01/04/how-many-charactors-in-a-java-string/)
