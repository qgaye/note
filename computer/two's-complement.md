# 补码(two's complement)

注：瞎几把写的，补码还是没有搞懂...

数字在计算机中都是以补码的形式存储的，其带来的好处就是数字间无论是加法还是减法都可以通过加法器完成，此外在补码中只存在一个0，而不像反码中存在正负两个0

接着来解释一下为什么数字要以补码的形式存储

```txt
    二进制       原码      补码
    000          0        0
    001          1        1
    010          2        2
    011          3        3
    100          4        -4
    101          5        -3
    110          6        -2
    111          7        -1
```

先来看正数的减法，因为CPU中没有减法器只有加法器，因此必须将减法转为加法来计算，理论上减法是不可能转化为加法的，但是在计算机中有一点特殊，就是数字一定使用固定位数表示存储的，比如上例中就用了三位二进制来表示一个数，因此能表示的最大值也就是7，当计算`7 + 1`为`1000`时，最高位的1因为溢出就被舍弃了(因为只有3位来存储，最高位的1没地方存了自然就没用了)，于是`1000`因为溢出就成了`000`也就是0，于是我们就能发现因为位数固定的原因，其实整个运算可以看作一个圈

```txt
          0
       7     1
     6         2
       5      3
          4
```

加法运算就是顺时针向前移动，当绕了一圈重新回到顶点时也就是发生了溢出，而是减法运算也就可以看作逆时针向后移动，因为是一个圈，逆时针能走到的地方顺时针也能走到，因此减法可以用加法来计算，举个例子，`6 - 4`也就等于`6 + (8 - 4)`，其中8也就是一圈的总数，`8 - 4`也就是将逆时针转化为了顺时针，计算结果为`10 = 8 + 2`，也就是绕了一整圈后再走两格。但此时`6 + (8 - 4)`中还是存在着减法，让我们将`8 - 4`化为二进制来看`1000 - 100`可以再转化为`(111 + 1) - 100 = (111 - 100) + 1`，其中`111 - 100`这个减法在二进制中比较特殊，可以理解为全部取反，于是乎就将`8 - 4`这个减法转化为了取反后加一的运算

因为`6 - 4 = 6 + (-4) = 6 + (8 - 4)`，`8 - 4`计算得处二进制为100，因此-4的二进制也就是100，以此类推就能将原先正数构成的圈加入负数

```txt
           0
       -1     1
     -2         2
       -3     3
          -4
```

反码在英文中是ones' complement，也就是对1求补，比如3位的二进制数的反码就是`111 - num`，也就是每位取反
补码在英文中是two's complement，也就是对2求补，比如3位的二进制数的补码就是`1000 - num`，根据上面推理`1000 - num = 111 - num + 1`即每位取反后+1

反码：正数的反码就是自身，负数的反码就是除符号位外每位取反
补码：正数的补码就是自身，负数的补码就是除符号位外每位取反后加1，即求其反码后加1
