# 如何设计一个秒杀系统

## 秒杀架构：

1. 数据尽量少：上传和返回的数据量尽量少，因为数据在网络传输和压缩编码都是消耗性能的时间的
2. 请求数尽量少：每多一次请求就多建立一个连接，建立连接需要做三次握手
3. 路径尽量短：发起请求到返回结果的过程中经过的中间节点数要少，首先每经过一个节点都需要新建一个Socket连接，此外每多经过一个节点也就增加了新的不确定性
4. 依赖尽量少：减少强依赖，也就是必须的上下游服务，对于弱依赖的上下游服务，必要时可以降级
5. 不要有单点：没有备份，即风险不可控，通过冗余部署避免

## 具体措施：

1. 把秒杀系统独立拆分成一个单独系统
2. 将秒杀系统单独部署在一个集群上，这样秒杀流量就不会影响正常流量了
3. 将热点数据（比如库存）单独放到一个缓存系统中
4. 增加答题秒杀，拦截非人为流量
5. 页面动静分离，秒杀时无需刷新整个页面，而只需要点击指定按钮，减少数据请求量
6. 增加限流和降级

动静分离：静态数据要尽量离用户近，比如CDN或直接缓存在客户端，CDN的优势在于可以主动置失效

## 热点数据：

及时发现热点数据：
1. 静态热点数据：可预知的，比如商家主动申报的热点商品
2. 动态热点数据：不可预知的，需要通过大数据实时分析得出

如何发现动态热点数据：
1. 异步收集交易链路上各个环节热点key（如缓存、rpc等）
2. 热点上报，将交易链路上各个环节收集到的热点key信息上报到统一热点数据分析平台
3. 统一热点数据分析平台对热点key数据进行分析，并将对应的热点信息推送给交易链路上的各个服务（这些服务需要先向热点数据分析平台订阅）

处理热点数据：
1. 优化：缓存热点数据
2. 限制：将流量hash分桶，防止热点数据请求抢占太多资源，而其他请求始终得不到资源
3. 隔离：将热点数据流量隔离出来，不要让热点流量影响到剩余所有流量，并且隔离出来后更方便针对性优化
   - 业务隔离：将秒杀做成一种营销活动，保证秒杀的热点数据可以做预热
   - 系统隔离：运行隔离，秒杀单独作为一个系统发布部署
   - 数据隔离：将秒杀的热点数据放在单独缓存或DB中

## 削峰

削峰：延缓用户请求的发出（打散请求发出的时间），过滤掉无效请求
1. 消息队列：将同步转为异步请求，但存在消息积压达到机器存储上限的问题（不用MQ也可以自行将请求异步序列化到文件中再顺序读取文件恢复请求）
2. 答题：首先可以过滤作弊秒杀器，其次可以延缓请求，因为答题肯定需要时间，也就可以将原来1s内打过来的请求分散到1-10s内（答题校验是可以带上userId、timestamp、商品Id做MD5进行答案校验）（除了答题，像摇一摇也可能进行延缓请求，本质就是打散请求发出时间，避免都是同一时间发出请求）
3. 分层过滤：在不同层尽可能过滤掉无效请求，让末端（DB）都是有效请求（读系统中尽量减少一致性校验带来的系统瓶颈，但尽可能将不影响性能的条件校验前置，而写系统中做一致性校验，确保数据库层面数据最终准确性）

## 性能

性能：服务端性能指标：QPS（每秒请求数），RT（响应时间），总QPS = (1s / 响应时间) * 线程数量
响应时间 = CPU执行时间 + 线程等待时间（RPC、IO等待）
因为线程等待基本不消耗服务器资源（注意要开足够的线程数量，否则会因为线程数不足请求被直接拒绝，影响吞吐量），真正对性能有影响的是CPU执行时间，因为这是真正消耗了服务器资源
其次线程数也不是越多越好，因为线程切换本身就有成本，其次线程本身也占用内存，线程数 = [(线程等待时间 + 线程CPU时间) / 线程CPU时间] * CPU数量，最好的方法还是通过性能测试来得到最佳线程数
服务器性能出现瓶颈的地方有CPU、内存、磁盘、网络等，当QPS达到极限时观察服务器数据，使用率过高的部分就是瓶颈

优化系统性能：
1. 减少编码：Java编码运行较慢，无论是磁盘IO还是网络IO都需要将字符串编码成字节，每个字符的编码都需要查表，所以非常消耗性能。可以通过提前将静态字符串编码成字节缓存，以提升性能
2. 减少序列化：序列化大部分发生在RPC调用，减少RPC调用就可以减少序列化，并且序列化和编码往往是同时发生的，减少序列化也就减少了编码。此外可以将目标服务合并部署在同一机器的同一Tomcat容器中，且不能走本地Socket以避免序列化
3. 直接使用Servlet处理请求：避免使用传统MVC框架，可以绕过一大堆复杂且用处不大的逻辑
4. 并发读优化：当超出Redis/Tair集中式缓存的热点请求，可以直接使用机器的内存(LocalCache)，读场景允许一定的脏数据，等到真正写数据时再保证最终一致性
   
性能优化的核心：
1. 减少数据：编码和网络传输都和数据大小密切相关，数据越少处理的越快
2. 减少中间环节：减少RPC调用，从而减少序列化和编码
3. 数据分级：重要数据优先，次要数据可以异步加载
此外，还需要做好应用基线（性能基线、成本基线、链路基线），通过基线关注系统性能，从而优化代码质量和不合理的调用

## 库存

库存：
1. 下单减库存：存在恶意下单抢占所有库存（需要风控）
2. 付款减库存：存在用户到付款阶段扣库存失败的情况，体验不佳
3. 预扣库存

减库存一致性：如果商品数量较少、交易时间较短可以将库存扣减在Redis缓存中完成，其他情况就必须在数据库中完成扣减（数据库中对同一行记录的操作是串行执行的）

使用Redis扣减库存：
1. 通过lua脚本实现原子操作扣减库存（查库存和扣库存的原子性）
2. 先向Redis申请分布式锁，只有申请到分布式锁的才能执行库存检查和扣库存
通过Redis尽可能拦掉大部分超库存的请求，减少数据库压力，而真正库存的一致性由数据库控制
此外，为了防止秒杀商品库存这个热点key影响Redis实例性能，可以将库存拆分开来分到多个实例上，但这样查总库存需要查多个实例数据，并且还要保证同用户只会请求到同一实例上和流量按各实例库存比例分发

MySQL中对并发对同一行记录操作就会造成大量线程并发竞争InnoDB行锁，并发度越高等待时间越长，TPS（每秒事务处理量）就会降低，RT（响应时间）就会上升，数据库吞吐量就会被严重影响（这就会导致单个热点商品影响到了其他所有商品）

分离热点商品到单独数据库（按商品ID分库分表）+ 应用层排队（单机对数据库同一行记录操作的并发度，控制单个商品占用数据库连接数，防止热点商品影响到其他商品的正常下单） + 数据库层排队（应用层排队是单机纬度的，而数据库层面可以对同一行记录做全局的排队）

为什么要对同一行记录做排队？因为MySQL中为了防止死锁有行锁检测，每当新来一个被阻塞的线程，就会判断会不会因为自己的加入导致死锁，这是时间复杂度O(n)的操作，虽然秒杀场景下并不会发生死锁，但检测的过程需要消耗大量CPU资源，所以如果MySQL不支持对同一行记录排队，那么不建议把库存扣减操作都放到数据库中执行

## 高可用

高可用：
1. 架构阶段：系统的可扩展性和容错性
2. 编码阶段：保证代码的健壮性，对异常的捕获和处理，对RPC调用设置合理超时时间防止拖垮系统
3. 测试阶段：测试用例的覆盖度
4. 发布阶段：紧急回滚机制
5. 运行阶段：对系统的监控要准确及时，能够发现问题并及时报警
6. 故障发生：能够立即止损，然后定位问题恢复服务

降级：当系统容量到一定程度后，限制或关闭某些非核心功能，从而把有限资源留给更核心的业务（自动降级，当qps到达压测得到的某个阈值后，通过开关自动降级）
限流：当系统容量到达瓶颈后，通过限制一部分流量来保护系统，基于QPS和线程数进行限流，QPS可以根据压测获取到阈值，超出线程数的请求直接抛弃
   - 客户端限流：直接限制请求的发出，但客户端较分散时无法合理设置限流阈值
   - 服务端限流：服务端可以合理设置阈值，但服务端处理这些被限流的请求本身也是消费服务器资源的
拒绝服务：直接拒绝请求，防止最坏情况发生的兜底方案

预防：单机压测 + 全链路压测
管控：降级 + 限流 + 兜底保护
监控：性能基线 + 波动报警
恢复：及时止损 + 数据恢复

Cache失效：为了保证Cache和DB数据一致性，就必然存在失效问题
- 被动失效：对时效性不太敏感的数据设置一定的失效时间自动失效，配合后台管理界面在紧急情况下可以手动失效某些Cache
- 主动失效：失效中心负责监听DB的变更（有中间件负责解析MySQL的binlog，发现insert、update、delete等操作时将数据变更转成一个消息发给订阅方），失效中心将失效请求发给Cache完成清楚失效数据的操作

将所有请求放到一个队列中排队处理，虽然可以有效削峰，但对用户体验不佳，因为是异步方式，用户就需要较长时间等待结果
异步请求返回结果：
- 客户端轮询：客户端每隔一定时间就去请求服务端尝试获取请求结果，但会造成服务端的请求数量增加
- 服务端push：服务端处理完请求后主动推送给客户端，但需要服务端和客户端保持连接，服务端的连接数就会比较多


